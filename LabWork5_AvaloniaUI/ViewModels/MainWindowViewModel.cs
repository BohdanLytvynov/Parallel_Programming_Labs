using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using LabWork5.MatrixCalculators;
using LabWork5.RandomMatrixFillers;
using LabWork5_AvaloniaUI.Enums;
using LabWork5_AvaloniaUI.Helpers;
using LabWork5_AvaloniaUI.Managers;
using LabWork5_AvaloniaUI.Messages.Calculations;
using LabWork5_AvaloniaUI.Messages.Dialogs;
using LabWork5_AvaloniaUI.Messages.Progress;
using LabWork5_AvaloniaUI.Models;
using LabWork5_AvaloniaUI.Strings;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace LabWork5_AvaloniaUI.ViewModels
{
    //We use PARTIAL here cause some part of the code is generated by Avalonia code generator
    public partial class MainWindowViewModel : ObservableValidator, IDisposable
    {
        #region Fields
        private IProgress<double> m_progress;//Progress object
        private IRandomMatrixFiller m_randomMatrixFiller;
        private IMatrixCalculator m_matrixCalculator;
        private IWindowManager m_windowManager;
        private CancellationTokenSource m_cancellationTokenSource;//Object responsive for Calculation
        private bool m_calc_Possible = false;
        private Stopwatch m_stopWatch;//Timer

        public bool ShowGridLines { get; set; } = false;//System Property in Prod must be false
        public string Title { get; } = UIStrings.AppName;
        //List of possible operations
        public ObservableCollection<MatrixOperation> Operations { get; set; } = new()
        {
            new MatrixOperation(){ Name = "+", Operation = Operation.Add },
            new MatrixOperation(){ Name = "-", Operation = Operation.Subtract },
            new MatrixOperation(){ Name = "*", Operation = Operation.Multiply }
        };

        private bool m_matAReady = false;
        private bool m_matBReady = false;

        [ObservableProperty]
        private bool mainIsEnabled = true;

        [ObservableProperty]//makes the field observable
        private bool canOperationSelected = false;

        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(CalculateCommand))]//When the property was changed it calls the CalculateCommand.CanExecute
        private int selectedOperationIndex = -1;

        [ObservableProperty]
        [NotifyDataErrorInfo]//used for validation. Tells Avalonia that this property must be validated
        [NotifyCanExecuteChangedFor(nameof(GenerateMatCommand))]
        [Required(ErrorMessage = "Field cannot be empty")]//One of validation conditions
        [Range(1, int.MaxValue, ErrorMessage = "Value must be greater then 0!")]//Another validation condition
        private int? rowsA = 0;

        [ObservableProperty]
        [NotifyDataErrorInfo]
        [NotifyCanExecuteChangedFor(nameof(GenerateMatCommand))]
        [Required(ErrorMessage = "Field cannot be empty")]
        [Range(1, int.MaxValue, ErrorMessage = "Value must be greater then 0!")]
        private int? colsA = 0;

        [ObservableProperty]
        [NotifyDataErrorInfo]
        [NotifyCanExecuteChangedFor(nameof(GenerateMatCommand))]
        [Required(ErrorMessage = "Field cannot be empty")]
        [Range(1, int.MaxValue, ErrorMessage = "Value must be greater then 0!")]
        private int? rowsB = 0;

        [ObservableProperty]
        [NotifyDataErrorInfo]
        [NotifyCanExecuteChangedFor(nameof(GenerateMatCommand))]
        [Required(ErrorMessage = "Field cannot be empty")]
        [Range(1, int.MaxValue, ErrorMessage = "Value must be greater then 0!")]
        private int? colsB = 0;

        private double[,] m_MatrixA;//Math representation of the Matrix
        private double[,] m_MatrixB;//Math representation of the Matrix

        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(CalculateCommand))]
        private ObservableCollection<double[]> matAPresenter;

        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(CalculateCommand))]
        private ObservableCollection<double[]> matBPresenter;

        #endregion

        #region Ctor

        public MainWindowViewModel()
        {
            ValidateAllProperties();//Call it first to validate all properties with NotifyDataErrorInfo attribute
            //register handler that will cancel current operation
            WeakReferenceMessenger.Default.Register<CalculationCanceledMessage>(this, (o, e) =>
            {
                m_cancellationTokenSource!.Cancel();
            });
        }

        public MainWindowViewModel(
            IRandomMatrixFiller randomMatrixFiller, 
            IMatrixCalculator matrixCalculator,
            IWindowManager windowManager) : this()
        {
            m_randomMatrixFiller = randomMatrixFiller ?? throw new ArgumentNullException(nameof(randomMatrixFiller));
            m_matrixCalculator = matrixCalculator ?? throw new ArgumentNullException(nameof(matrixCalculator));
            m_windowManager = windowManager ?? throw new ArgumentNullException(nameof(windowManager));
            //Calculation flow events
            m_matrixCalculator.OnParallelCalculationStarted += M_matrixCalculator_OnParallelCalculationStarted;
            m_matrixCalculator.OnParallelCalculationFinished += M_matrixCalculator_OnParallelCalculationFinished;
        }

        private async void M_matrixCalculator_OnParallelCalculationFinished(string arg1, double[,] arg2)
        {
            m_stopWatch.Stop();//Stop Timer
            await Dispatcher.UIThread.InvokeAsync(async () =>
            {
                var dialog = m_windowManager.Build<ResultWindow>();//Build result Window

                WeakReferenceMessenger.Default?.Send(new ProgressCloseMessage(true));//Notify Progress Dialog that it has to close
                //Notify Result Window that calculation was finished
                WeakReferenceMessenger.Default?.Send(new CalculationFinishedMessage(
                        new OperationDetails() { Name = GetOperationName(SelectedOperationIndex), Mat = arg2,
                        ElapsedTime = m_stopWatch.Elapsed.TotalSeconds}
                        ));

                if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
                {
                    dialog.WindowStartupLocation = Avalonia.Controls.WindowStartupLocation.CenterScreen;
                    await dialog.ShowDialog(desktop.MainWindow);
                }
            });
        }

        private async void M_matrixCalculator_OnParallelCalculationStarted(string obj)
        {
            m_stopWatch = Stopwatch.StartNew();//Start Timer
            await Dispatcher.UIThread.InvokeAsync(async () =>
            {
                //We use Dispatcher here cause it can be called from the background thread.
                //And we need to post some work to the UI thread.
                var dialog = m_windowManager.Build<ProgressDialog>();//Create Progress Dialog
                if (dialog == null) return;
                //Notify progress dialog that calculation was started
                WeakReferenceMessenger.Default?.Send(new CalculationStartedMessage(
                    GetOperationName(SelectedOperationIndex)
                ));
                //Show dialog
                if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
                {
                    dialog.WindowStartupLocation = Avalonia.Controls.WindowStartupLocation.CenterScreen;
                    //Here the dialog will be shown and code will continue to execute in another place
                    //Code after this line will be executed only when the Dialog will be closed
                    await dialog.ShowDialog(desktop.MainWindow);
                }
            });
        }

        #endregion

        #region Methods
        /// <summary>
        /// Determines if generate button can be pressed
        /// </summary>
        /// <param name="p">Matrix A or B, set form view</param>
        /// <returns></returns>
        private bool CanGenerateMat(string? p)
        {
            if (p == "A")
            {
                bool hasErrorsA = GetErrors(nameof(RowsA)).Any() || GetErrors(nameof(ColsA)).Any();
                return !hasErrorsA && RowsA.HasValue && ColsA.HasValue;
            }

            if (p == "B")
            {
                bool hasErrorsB = GetErrors(nameof(RowsB)).Any() || GetErrors(nameof(ColsB)).Any();
                return !hasErrorsB && RowsB.HasValue && ColsB.HasValue;
            }

            return false;
        }
        /// <summary>
        /// Async version of the command
        /// </summary>
        /// <param name="p">Matrix A or B, set form view</param>
        /// <returns></returns>
        [RelayCommand(CanExecute = nameof(CanGenerateMat))]//Determines that this method is a command, and also we bind CanGenerateMat 
        private async Task GenerateMat(string? p)
        {
            if (p == null) return;
            m_cancellationTokenSource = new CancellationTokenSource();
            var progress = m_windowManager.Build<ProgressDialog>();//Create progress dialog
            //Notify progress dialog that calculation was started 
            WeakReferenceMessenger.Default?.Send(new CalculationStartedMessage(
                "Matrix Generation"
                ));
            //Open window after we notify ProgressDialog
            if (Application.Current.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop 
                && desktop != null && progress != null)
            {
                progress.WindowStartupLocation = Avalonia.Controls.WindowStartupLocation.CenterScreen;
                EnableMain(false);
                progress.Show(desktop.MainWindow);//but it ruins the modal window logic
            }

            //Init progress object
            m_progress = new Progress<double>(h =>
            {
                //Will be called when the Report method will be called in FillAsync method
                WeakReferenceMessenger.Default?.Send(new ProgressChangedMessage(h));
            });
            
            if (p.Equals("A"))
            {
                m_MatrixA = new double[(int)RowsA, (int)ColsA];
                await m_randomMatrixFiller.FillAsync(m_MatrixA, m_cancellationTokenSource, m_progress);
                EnableMain(true);
                var r = await UIHelper.MatToMatPresenterAsync(m_MatrixA);
                Dispatcher.UIThread.Post(() =>
                {
                    //Update UI
                    MatAPresenter = new ObservableCollection<double[]>(r);
                });
            }
            else if (p.Equals("B"))
            { 
                m_MatrixB = new double[(int)RowsB, (int)ColsB];
                await m_randomMatrixFiller.FillAsync(m_MatrixB, m_cancellationTokenSource, m_progress);
                EnableMain(true);
                //This code will be executed only after previous line will be completed
                MatBPresenter = new ObservableCollection<double[]>();
                var r = await UIHelper.MatToMatPresenterAsync(m_MatrixB);
                Dispatcher.UIThread.Post(() => 
                {
                    MatBPresenter = new ObservableCollection<double[]>(r);
                });
            }
            //Tell the progress dialog that it must be closed
            WeakReferenceMessenger.Default?.Send(new ProgressCloseMessage(true));
        }

        [RelayCommand]//This is the command that can be executed without any conditions
        private void Exit()
        {
            if (Avalonia.Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                desktop.Shutdown();//Correct exit from the App
            }
        }
        //Can Calculation take place? must return bool, even if we use async Task in a Command function
        private bool CanCalculate()
        { 
            return SelectedOperationIndex >= 0 && 
                MatAPresenter.Count > 0 && 
                MatBPresenter.Count > 0 && 
                m_calc_Possible;
        }

        [RelayCommand(CanExecute = nameof(CanCalculate))]
        private void Calculate()
        {
            //Here code will be executed async mode
            //to due to usage of ContinueWith and event model for returning the results
            m_cancellationTokenSource = new CancellationTokenSource();
            m_progress = new Progress<double>(h =>
            {
                WeakReferenceMessenger.Default.Send(new ProgressChangedMessage(h));
            });

            switch (Operations[SelectedOperationIndex].Operation)
            {
                case Operation.Add:
                    if (m_matrixCalculator.AddSubtractPossible(m_MatrixA, m_MatrixB))
                    {
                        m_matrixCalculator.ParallelAdd(m_MatrixA, m_MatrixB, m_cancellationTokenSource, m_progress);
                    }
                    break;
                case Operation.Subtract:
                    if (m_matrixCalculator.AddSubtractPossible(m_MatrixA, m_MatrixB))
                    {
                        m_matrixCalculator.ParallelSubtract(m_MatrixA, m_MatrixB, m_cancellationTokenSource, m_progress);
                    }
                    break;
                case Operation.Multiply:
                    if (m_matrixCalculator.MultiplicationPossible(m_MatrixA, m_MatrixB))
                    {
                        m_matrixCalculator.ParallelMultiply(m_MatrixA, m_MatrixB, m_cancellationTokenSource, m_progress);
                    }
                    break;
            }
        }
        /// <summary>
        /// Partial method will be called when MatAPresenter object will change
        /// </summary>
        /// <param name="value"></param>
        partial void OnMatAPresenterChanged(ObservableCollection<double[]> value)
        {
            m_matAReady = MatAPresenter != null && MatAPresenter.Count > 0;
            CanOperationSelected = m_matAReady && m_matBReady;
        }

        partial void OnMatBPresenterChanged(ObservableCollection<double[]> value)
        {
            m_matBReady = MatBPresenter != null && MatBPresenter.Count > 0;
            CanOperationSelected = m_matAReady && m_matBReady;
        }

        partial void OnSelectedOperationIndexChanged(int value)
        {
            if (value == -1) return;

            CheckIfOperationIsPossibleCommand.ExecuteAsync(value);
        }

        [RelayCommand]
        private async Task CheckIfOperationIsPossible(int value)
        {
            if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                var dialog = m_windowManager.Build<MatrixCalcDialog>();
                dialog.WindowStartupLocation = Avalonia.Controls.WindowStartupLocation.CenterScreen;
                switch (Operations[value].Operation)
                {
                    case Operation.Add:
                    case Operation.Subtract:
                        if (!m_matrixCalculator.AddSubtractPossible(m_MatrixA, m_MatrixB))
                        {
                            SendMessageToDialog(new DialogMessageContent()
                            {
                                MessageType = MessageType.Error,
                                Message = string.Format(UIStrings.InvalidOperError,
                                Operations[SelectedOperationIndex].Operation.ToString(),
                                "Incorrect matrices dimensions for this operation!")
                            });

                            m_calc_Possible = false;
                            await dialog!.ShowDialog(desktop.MainWindow);
                        }
                        break;
                    case Operation.Multiply:
                        if (!m_matrixCalculator.MultiplicationPossible(m_MatrixA, m_MatrixB))
                        {
                            SendMessageToDialog(new DialogMessageContent()
                            {
                                MessageType = MessageType.Error,
                                Message = string.Format(UIStrings.InvalidOperError,
                                Operations[SelectedOperationIndex].Operation.ToString(),
                                "Incorrect matrices dimensions for this operation!")
                            });

                            m_calc_Possible = false;
                            await dialog!.ShowDialog(desktop.MainWindow);
                        }
                        break;
                }
            }
            m_calc_Possible = true;
        }

        private void SendMessageToDialog(DialogMessageContent dialogMessageContent)
        {
            DialogMessage dialogMsg = new DialogMessage(dialogMessageContent);
            WeakReferenceMessenger.Default.Send(dialogMsg);
        }

        public void Dispose()
        {
            //Don't forget to cleanup - IDisposable is the same as the RAII
            m_matrixCalculator.OnParallelCalculationStarted -= M_matrixCalculator_OnParallelCalculationStarted;
            m_matrixCalculator.OnParallelCalculationFinished -= M_matrixCalculator_OnParallelCalculationFinished;
            WeakReferenceMessenger.Default?.Unregister<CalculationCanceledMessage>(this);
        }

        private string GetOperationName(int index)
        { 
            return Operations[index].Operation.ToString();
        }

        [RelayCommand]
        private void Clear(string p)
        { 
            if(p == null) return;

            if (p == "A")
            {
                m_MatrixA = null;
                MatAPresenter?.Clear();
                RowsA = 0;
                ColsA = 0;
            }
            else if (p == "B")
            {
                m_MatrixB = null;
                MatBPresenter?.Clear();
                RowsB = 0;
                ColsB = 0;
            }
        }

        private void EnableMain(bool enable)
        {
            MainIsEnabled = enable;
        }
        #endregion



    }
}
